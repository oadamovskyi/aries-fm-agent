"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediatorService = void 0;
const AgentConfig_1 = require("../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../agent/EventEmitter");
const constants_1 = require("../../../constants");
const error_1 = require("../../../error");
const plugins_1 = require("../../../plugins");
const JsonTransformer_1 = require("../../../utils/JsonTransformer");
const connections_1 = require("../../connections");
const ConnectionMetadataTypes_1 = require("../../connections/repository/ConnectionMetadataTypes");
const helpers_1 = require("../../dids/helpers");
const RoutingEvents_1 = require("../RoutingEvents");
const messages_1 = require("../messages");
const MediationRole_1 = require("../models/MediationRole");
const MediationState_1 = require("../models/MediationState");
const repository_1 = require("../repository");
const MediationRecord_1 = require("../repository/MediationRecord");
const MediationRepository_1 = require("../repository/MediationRepository");
const MediatorRoutingRepository_1 = require("../repository/MediatorRoutingRepository");
let MediatorService = class MediatorService {
    constructor(mediationRepository, mediatorRoutingRepository, agentConfig, wallet, eventEmitter, connectionService) {
        this.mediationRepository = mediationRepository;
        this.mediatorRoutingRepository = mediatorRoutingRepository;
        this.agentConfig = agentConfig;
        this.wallet = wallet;
        this.eventEmitter = eventEmitter;
        this.connectionService = connectionService;
    }
    async initialize() {
        this.agentConfig.logger.debug('Mediator routing record not loaded yet, retrieving from storage');
        let routingRecord = await this.mediatorRoutingRepository.findById(this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID);
        // If we don't have a routing record yet, create it
        if (!routingRecord) {
            this.agentConfig.logger.debug('Mediator routing record does not exist yet, creating routing keys and record');
            const { verkey } = await this.wallet.createDid();
            routingRecord = new repository_1.MediatorRoutingRecord({
                id: this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID,
                routingKeys: [verkey],
            });
            await this.mediatorRoutingRepository.save(routingRecord);
        }
        this._mediatorRoutingRecord = routingRecord;
    }
    getRoutingKeys() {
        if (this._mediatorRoutingRecord) {
            // Return the routing keys
            this.agentConfig.logger.debug(`Returning mediator routing keys ${this._mediatorRoutingRecord.routingKeys}`);
            return this._mediatorRoutingRecord.routingKeys;
        }
        throw new error_1.AriesFrameworkError(`Mediation service has not been initialized yet.`);
    }
    async processForwardMessage(messageContext) {
        const { message } = messageContext;
        // TODO: update to class-validator validation
        if (!message.to) {
            throw new error_1.AriesFrameworkError('Invalid Message: Missing required attribute "to"');
        }
        const mediationRecord = await this.mediationRepository.getSingleByRecipientKey(message.to);
        // Assert mediation record is ready to be used
        mediationRecord.assertReady();
        mediationRecord.assertRole(MediationRole_1.MediationRole.Mediator);
        return {
            encryptedMessage: message.message,
            mediationRecord,
        };
    }
    async processKeylistUpdateRequest(messageContext) {
        // Assert Ready connection
        const connection = messageContext.assertReadyConnection();
        const { message } = messageContext;
        const keylist = [];
        const mediationRecord = await this.mediationRepository.getByConnectionId(connection.id);
        mediationRecord.assertReady();
        mediationRecord.assertRole(MediationRole_1.MediationRole.Mediator);
        // Update connection metadata to use their key format in further protocol messages
        const connectionUsesDidKey = message.updates.some((update) => helpers_1.isDidKey(update.recipientKey));
        await this.updateUseDidKeysFlag(connection, messages_1.KeylistUpdateMessage.type.protocolUri, connectionUsesDidKey);
        for (const update of message.updates) {
            const updated = new messages_1.KeylistUpdated({
                action: update.action,
                recipientKey: update.recipientKey,
                result: messages_1.KeylistUpdateResult.NoChange,
            });
            // According to RFC 0211 key should be a did key, but base58 encoded verkey was used before
            // RFC was accepted. This converts the key to a public key base58 if it is a did key.
            const publicKeyBase58 = helpers_1.didKeyToVerkey(update.recipientKey);
            if (update.action === messages_1.KeylistUpdateAction.add) {
                mediationRecord.addRecipientKey(publicKeyBase58);
                updated.result = messages_1.KeylistUpdateResult.Success;
                keylist.push(updated);
            }
            else if (update.action === messages_1.KeylistUpdateAction.remove) {
                const success = mediationRecord.removeRecipientKey(publicKeyBase58);
                updated.result = success ? messages_1.KeylistUpdateResult.Success : messages_1.KeylistUpdateResult.NoChange;
                keylist.push(updated);
            }
        }
        await this.mediationRepository.update(mediationRecord);
        return new messages_1.KeylistUpdateResponseMessage({ keylist, threadId: message.threadId });
    }
    async createGrantMediationMessage(mediationRecord) {
        // Assert
        mediationRecord.assertState(MediationState_1.MediationState.Requested);
        mediationRecord.assertRole(MediationRole_1.MediationRole.Mediator);
        await this.updateState(mediationRecord, MediationState_1.MediationState.Granted);
        // Use our useDidKey configuration, as this is the first interaction for this protocol
        const useDidKey = this.agentConfig.useDidKeyInProtocols;
        const message = new messages_1.MediationGrantMessage({
            endpoint: this.agentConfig.endpoints[0],
            routingKeys: useDidKey ? this.getRoutingKeys().map(helpers_1.verkeyToDidKey) : this.getRoutingKeys(),
            threadId: mediationRecord.threadId,
        });
        return { mediationRecord, message };
    }
    async processMediationRequest(messageContext) {
        // Assert ready connection
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = new MediationRecord_1.MediationRecord({
            connectionId: connection.id,
            role: MediationRole_1.MediationRole.Mediator,
            state: MediationState_1.MediationState.Requested,
            threadId: messageContext.message.threadId,
        });
        await this.mediationRepository.save(mediationRecord);
        this.emitStateChangedEvent(mediationRecord, null);
        return mediationRecord;
    }
    async findById(mediatorRecordId) {
        return this.mediationRepository.findById(mediatorRecordId);
    }
    async getById(mediatorRecordId) {
        return this.mediationRepository.getById(mediatorRecordId);
    }
    async getAll() {
        return await this.mediationRepository.getAll();
    }
    async findAllByQuery(query) {
        return await this.mediationRepository.findByQuery(query);
    }
    async updateState(mediationRecord, newState) {
        const previousState = mediationRecord.state;
        mediationRecord.state = newState;
        await this.mediationRepository.update(mediationRecord);
        this.emitStateChangedEvent(mediationRecord, previousState);
    }
    emitStateChangedEvent(mediationRecord, previousState) {
        const clonedMediationRecord = JsonTransformer_1.JsonTransformer.clone(mediationRecord);
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
            payload: {
                mediationRecord: clonedMediationRecord,
                previousState,
            },
        });
    }
    async updateUseDidKeysFlag(connection, protocolUri, connectionUsesDidKey) {
        var _a;
        const useDidKeysForProtocol = (_a = connection.metadata.get(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol)) !== null && _a !== void 0 ? _a : {};
        useDidKeysForProtocol[protocolUri] = connectionUsesDidKey;
        connection.metadata.set(ConnectionMetadataTypes_1.ConnectionMetadataKeys.UseDidKeysForProtocol, useDidKeysForProtocol);
        await this.connectionService.update(connection);
    }
};
MediatorService = __decorate([
    plugins_1.injectable(),
    __param(3, plugins_1.inject(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [MediationRepository_1.MediationRepository,
        MediatorRoutingRepository_1.MediatorRoutingRepository,
        AgentConfig_1.AgentConfig, Object, EventEmitter_1.EventEmitter,
        connections_1.ConnectionService])
], MediatorService);
exports.MediatorService = MediatorService;
//# sourceMappingURL=MediatorService.js.map